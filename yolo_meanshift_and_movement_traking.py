# -*- coding: utf-8 -*-
"""yolo_meanshift and movement traking.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s_j1WJwcLWNbNi5jpJxKmkRM59GGl9CZ
"""

!pip install -r https://raw.githubusercontent.com/ultralytics/yolov5/master/requirements.txt

import cv2
import os
import numpy as np
from matplotlib import pyplot as plt
from sklearn.cluster import MeanShift,estimate_bandwidth
import numpy as np
import glob
import torch
from datetime import datetime
from numpy import linalg as LA

# Commented out IPython magic to ensure Python compatibility.
#clone YOLOv5 and 
!git clone https://github.com/ultralytics/yolov5  # clone repo
# %cd yolov5
# %pip install -qr requirements.txt

model_name='/weights/best.pt'
model = torch.hub.load('ultralytics/yolov5', 'custom', path=model_name, force_reload=True)

def _meanshift(resultNew):
    bandwidth = estimate_bandwidth(resultNew, quantile=0.2, n_samples=len(resultNew[:,1]))
    clustering = MeanShift(bandwidth=bandwidth).fit(resultNew)
    labels_unique = np.unique(clustering.labels_)
    n_clusters_ = len(labels_unique)

    y_pred  = clustering.predict(resultNew)
    a = np.array(y_pred)

    unique, counts = np.unique(a, return_counts=True)

    what = np.where(a == np.where(counts == np.max(counts))[0])[0]
    #   plt.scatter(resultNew[:, 0], resultNew[:, 1], c=a, cmap="viridis")
    return what

def diffMorq(imgOld,imgNew): # محاسبه فاصله مرغ ها
    results = model(imgOld)
    results1 = model(imgNew)
    
    Xmean1 = ((results.pandas().xyxy[0].xmax +  results.pandas().xyxy[0].xmin)/2 ).to_numpy()
    Ymean1 = ((results.pandas().xyxy[0].ymax +  results.pandas().xyxy[0].ymin)/2).to_numpy() *-1
    xyMean1 =  np.vstack((Xmean1, Ymean1)).T

    now = datetime.now()
    current_time = now.strftime("%H-%M-%S")

    if    int(current_time[-2:]) % 3 == 0 :
        what = _meanshift(xyMean1) # کلاستر
        overlay = imgOld.copy()
        for i in what:  
            Xpos = int((results.pandas().xyxy[0].xmax[i] + results.pandas().xyxy[0].xmin[i])/2)
            Ypos = int((results.pandas().xyxy[0].ymax[i] + results.pandas().xyxy[0].ymin[i])/2)
            cv2.circle(overlay,( Xpos, Ypos), 40, (0,0,255), thickness= -1)
            image_new = cv2.addWeighted(overlay, 0.3, imgOld, 1 - 0.3, 0)
        image_new = cv2.addWeighted(overlay, 0.4, imgOld, 1 - 0.4, 0)
        cv2.imwrite('./output_scattering/'+str(current_time)+'.jpg',image_new)

    Xmean2 = ((results1.pandas().xyxy[0].xmax +  results1.pandas().xyxy[0].xmin)/2 ).to_numpy()
    Ymean2 = ((results1.pandas().xyxy[0].ymax +  results1.pandas().xyxy[0].ymin)/2).to_numpy() *-1
    xyMean2 =  np.vstack((Xmean2, Ymean2)).T
    sizeVector  = 0
    diffVector = []
    if len(xyMean1) > len(xyMean2):
        sizeVector = len(xyMean2)
    else:
        sizeVector = len(xyMean1)
    for i in range(0,sizeVector):
        diff = LA.norm(xyMean1[i]-xyMean2[i],2)
        if diff < 1:
            diffVector.append([i,diff])
    
    if    int(current_time[-2:]) % 3 == 0 :
        what = _meanshift(xyMean1) # کلاستر
        overlay = imgOld.copy()
        for i in what:  
            Xpos = int((results.pandas().xyxy[0].xmax[i] + results.pandas().xyxy[0].xmin[i])/2)
            Ypos = int((results.pandas().xyxy[0].ymax[i] + results.pandas().xyxy[0].ymin[i])/2)
            cv2.circle(overlay,( Xpos, Ypos), 40, (0,0,255), thickness= -1)
            image_new = cv2.addWeighted(overlay, 0.3, imgOld, 1 - 0.3, 0)
        image_new = cv2.addWeighted(overlay, 0.4, imgOld, 1 - 0.4, 0)
        cv2.imwrite('./output_scattering/'+str(current_time)+'.jpg',image_new)

        overlay = imgOld.copy()

        if len(diffVector) != 0:
            meandiff=0
            for i in range(len(diffVector)):
                meandiff += diffVector[i][1]
            meandiff = meandiff/len(diffVector)
            for i in range(len(diffVector)):  
                if diffVector[i][1] < meandiff:
                    Xpos = int((results.pandas().xyxy[0].xmax[i] + results.pandas().xyxy[0].xmin[i])/2)
                    Ypos = int((results.pandas().xyxy[0].ymax[i] + results.pandas().xyxy[0].ymin[i])/2)
                    cv2.circle(overlay,( Xpos, Ypos), 25, (255,0,), thickness= -1)
            image_new = cv2.addWeighted(overlay, 0.3, imgOld, 1 - 0.3, 0)
            cv2.imwrite('./output_traking/'+str(current_time)+'.jpg',image_new)
        else:
            print("Not detection")

    return diffVector

# Commented out IPython magic to ensure Python compatibility.
# %cd /content
# %rm -R './output_scattering'
# %rm -R './output_traking'

# %mkdir ./output_scattering
# %mkdir ./output_traking

#Video file Or Camera device
cap= cv2.VideoCapture('1.mp4')

i=0
imgOld = []
#realTime  Read frame
diffVectors = []
while(cap.isOpened()):
    ret, frame = cap.read()
    if ret == False:
        break
    if i % 1 == 0 and i <= 0:
        imgOld = frame
    elif i % 1 == 0:
        # diffVectors.append(diffMorq(imgOld,frame))
        diffMorq(imgOld,frame)
        imgOld = frame
    i+=1
temp = np.zeros((300,1))
for _diff in diffVectors:
  for i in range(len(_diff)):
    temp[_diff[i][0]] += _diff[i][1]